# Azure IaC for Internal Auth Platform Data Stores

This Terraform stack provisions Azure infrastructure for the internal Account & Identity platform using FastAPI + PostgreSQL + Redis + Key Vault + Azure Monitor, aligned with the companion application architecture.

## What This Deploys

All resources are deployed into one resource group:

1. Azure Database for PostgreSQL Flexible Server
- System of record for users, credentials, memberships, organizations, refresh token hashes, audit events.
- Creates database `authdb`.
- Enforces TLS by setting:
  - `require_secure_transport=on`
  - `ssl_min_protocol_version=TLS1_2`

2. Azure Cache for Redis
- Used for rate limiting, lockout counters, and short-lived auth state.
- `enable_non_ssl_port=false`
- Minimum TLS version 1.2.

3. Azure Key Vault
- Stores runtime secrets consumed by the app:
  - `POSTGRES-CONNECTION-STRING`
  - `REDIS-HOSTNAME`
  - `REDIS-PRIMARY-KEY`
- Uses access policy for the current deploying identity by default.

4. Log Analytics Workspace
- Central telemetry backend for logs and platform diagnostics.

5. Application Insights (workspace-based)
- Application observability, traces, exceptions, request telemetry.

6. Azure Container Apps Environment (optional, default enabled)
- Runtime environment for hosting the FastAPI container later.
- Does not require app image at provisioning time.

7. Storage Account (optional, default enabled)
- Standard LRS account for future assets (avatars, artifacts).

## Why This Matches the App Architecture

- FastAPI app expects PostgreSQL + Redis + Key Vault-backed secrets.
- JWT access tokens are stateless, so no token store is provisioned.
- Refresh tokens are hashed and persisted in PostgreSQL (`authdb`).
- Rate limits and lockout counters are externalized into Redis.
- Observability is provided through Application Insights + Log Analytics.

## Prerequisites

- Azure CLI (`az`) installed and available in `PATH`
- Terraform `>= 1.6`
- Azure subscription with permission to create:
  - Resource groups
  - PostgreSQL Flexible Server
  - Redis Cache
  - Key Vault
  - Log Analytics and Application Insights
  - Container Apps Environment (optional)
  - Storage Account (optional)

## Setup

1. Copy and edit the env file:
```bash
cp iac/env.example iac/.env
```

2. Set required values in `iac/.env`:
- `SUBSCRIPTION_ID`
- `TENANT_ID`
- `ENV_NAME`

3. Optional: adjust any `TF_VAR_*` values for SKU/capacity/features.

## Multi-Instance (Independent) Operations

If you need multiple independently managed auth instances from one repo, use the instance profile model in `iac/instances/`.

1. Create per-instance files:
```bash
cp iac/instances/instance.env.example iac/instances/app1-dev.env
cp iac/instances/instance.backend.hcl.example iac/instances/app1-dev.backend.hcl
```

2. Deploy/update one instance:
```bash
bash iac/deploy-instance.sh app1-dev
```

3. Destroy one instance:
```bash
bash iac/destroy-instance.sh app1-dev
```

This pattern gives:
- per-instance config isolation (`iac/instances/<instance>.env`)
- per-instance state isolation (backend config + unique state key)
- per-instance execution isolation (Terraform workspace `<instance>`)

## Deploy

Run from repo root:
```bash
bash iac/deploy.sh
```

`deploy.sh` will:
1. Ensure Azure CLI login (tenant-aware using `TENANT_ID`)
2. Set active subscription
3. Run `terraform init`
4. Run `terraform apply -auto-approve`
5. Print key outputs

## Destroy

Run from repo root:
```bash
bash iac/destroy.sh
```

`destroy.sh` will:
1. Set active subscription
2. Print the resource group name being destroyed (safety check)
3. Require explicit `DESTROY` confirmation
4. Run `terraform destroy -auto-approve`

## Input Variables

Required:
- `subscription_id`
- `tenant_id`
- `env_name`

Defaults:
- `location = "uksouth"`
- `postgres_sku = "B_Standard_B1ms"`
- `postgres_storage_mb = 32768`
- `redis_sku = "Basic"`
- `redis_capacity = 0`
- `enable_container_apps_env = true`
- `enable_storage_account = true`

## Outputs

- `resource_group_name`
- `postgres_server_fqdn`
- `postgres_database_name`
- `key_vault_name`
- `redis_hostname`
- `application_insights_connection_string` (sensitive)
- `log_analytics_workspace_id`
- `container_apps_environment_id` (null if disabled)
- `redis_primary_access_key` (sensitive)

## App Secret Consumption from Key Vault

The FastAPI app should read Key Vault secrets at startup and map them to app config:

- `POSTGRES-CONNECTION-STRING` -> SQLAlchemy `DATABASE_URL`
- `REDIS-HOSTNAME` + `REDIS-PRIMARY-KEY` -> Redis URL/auth config

Recommended pattern for runtime apps:
1. Assign managed identity to app workload (Container Apps revision).
2. Grant Key Vault secret read permission to that identity.
3. Resolve secrets through Key Vault references or SDK at runtime.

## Security Defaults and Hardening

Current defaults are production-viable for internal dev/test and keep complexity low.

Already configured:
- Random PostgreSQL admin password generated by Terraform.
- Secrets stored in Key Vault (not hardcoded).
- TLS 1.2 enforced for PostgreSQL and Redis.
- PostgreSQL `sslmode=require` in generated connection string.

Hardening for stricter environments:
1. PostgreSQL private access:
- Set `TF_VAR_postgres_public_network_access_enabled=false`
- Add private networking (delegated subnet/private endpoints + private DNS)

2. Restrict PostgreSQL ingress:
- Keep public access enabled only if needed
- Set `TF_VAR_postgres_allowed_ips` to explicit admin/build-agent IPs
- Disable `TF_VAR_allow_azure_services` if not needed

3. Key Vault authorization model:
- Current code uses access policy for deployer
- Alternative: enable Key Vault RBAC and assign least-privilege roles (`Key Vault Secrets User`) to app identity

4. Managed identity for app:
- Use Container Apps managed identity to read Key Vault secrets
- Avoid injecting long-lived credentials into app config files

## Common Troubleshooting

1. `az login` issues
- Re-run: `az login --tenant <TENANT_ID>`
- Verify: `az account show`

2. Wrong subscription
- Verify active subscription:
  ```bash
  az account show --query id -o tsv
  ```
- Match it with `SUBSCRIPTION_ID` in `iac/.env`

3. Terraform provider errors
- Ensure Terraform version is 1.6+
- Reinitialize providers:
  ```bash
  terraform -chdir=iac init -upgrade
  ```

4. PostgreSQL connectivity failures
- Confirm `postgres_public_network_access_enabled` setting
- Confirm firewall allow-list contains your source IP when public access is enabled
- Ensure client uses SSL/TLS

5. Key Vault permission denied
- Confirm deploying identity matches active Azure CLI account
- Confirm access policy exists for that principal
